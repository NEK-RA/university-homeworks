# 100    Программа «Жизнь», (описывающая жизнь микроорганизмов)

Введение

Жили-были микробы. Жили они долго и счастливо, но вот одна беда: после жизни всегда
приходит смерть. А микробы были разные: маленькие и не очень, старички и малютки – и
у каждого из них был свой жизненный уровень. Так, например, у только что родившегося
микробчика он был равен 1, а по мере его взросления жизненный уровень тоже рос (от 1
до 12). Когда же микроб достигал последней ступени (т.е. 12), он, увы, погибал (теперь
его жизненный уровень равен 0). Если же у микроба уровень был равен 0, то он рождался
заново и проходил опять жизнь бодрым шагом от 1 до 12.
Всего же микробов в мире, как вы знаете, очень много, а жизнь их интересна. Поэтому
появилась идея написать программу, описывающую их жизнь. Эта программа должна
сообщать нам количество микробов в каждом поколении и «нарисовать» их на поле
(экране).

Программа должна работать следующим образом:

1. Сначала создаётся файл work.dat (жилище микробов) и файл work.out (описывающий
текущее поколение микробов, их развитие). Файл work.dat состоит из различных
символов, среди которых «обитают» микробы.
2. Необходимо создать массивы «настоящее» и «будущее». В массиве «настоящее»
записывается текущее поколение микробов, а в файл «будущее»- следующее. Массивы
создаются размером 21х21.
3. Программа выдаёт пользователю на экран запрос: «Введите количество поколений».
Именно столько поколений программа будет описывать.
4. Теперь программа создаёт в файле work.out поколение под номером 1. Для этого
программа открывает и проверяет на наличие микробов файл (каждый символ, среди
которых может затеряться микроб). Если под символом скрывается микроб (например,
символ «Х»), то в массив «настоящее» записывается единица (1, т.е. микроб только что
родился), а если не микроб – то ноль (0, т. е. там никто не живёт). Теперь в массиве
«настоящее» находиться поле из 1 и 0 (он состоит из новорожденных младенцев и
пустых мест). Все последующие поколения тоже записываются в файл work.out. Файл
work.dat закрывается, и работа теперь ведётся только с файлом work.out.
5. Теперь описывается следующее поколение. Оно создаётся после проверки массива
«настоящее». Проверяются микробы и их соседи (результат записывается в массив
«будущее»):

    - если жизненный уровень микроба от 1 до 11 то:
        - если соседей 2 или 3, то микроб продолжает жить и подрастает (т.е. его жизненный
уровень возрастает на 1),
        - иначе микроб погибает (=0), т.к. он задыхается или умирает от скуки;
    - если жизненный уровень микроба 0, то микроб рождается заново (т.е. его жизненный
уровень равен 1);
    - если жизненный уровень микроба равен 12, то микроб погибает (от
старости).
6. После проверки подсчитывается количество жизней данного поколения (т.е. сколько
единиц). Затем программа проверяет, есть ли кто «живой на поле» или все погибли
(т.е. нули).
7. Теперь программа производит замену поколений: массив «будущее» становится
«настоящим».
8. Программа продолжает работу с пункта 5 до тех пор, пока количество поколений
(которые описывает программа) не станет равным введенным пользователем в пункте
3 или пока не погибнут все микробы (т.е. везде одни нули).

***
# 101    Эмуляция 
Задание: написать развития программу популяций типа животных
 "Жизнь", но с некоторыми изменениями в начальных условиях.
Условия таковы, что в эмуляции должны участвовать две популяции: хищники и
травоядные, - которые взаимодействовали бы друг с другом путем поедания травоядных
хищниками.

Дополнительные параметры:

- возраст животных
- минимальный и максимальный репродуктивный возраст животных
- количество пищи нужный животным для поддержания жизни
- количество травы
- процент восстановления травы
- вероятность природных катаклизмов влияющих на популяции животных

Методика взаимодействий хищника и травоядного заключается в том, что и хищники, и
травоядные представлены в виде точек, которые передвигаются по экрану с шагом в один
пиксель. При этом заданно условие: если в радиусе один пиксель от точки,
принадлежащей хищнику, появляется точка, принадлежащая травоядному, то считается,
что хищник съел травоядного.

Способ передвижения точек на экране организуется по алгоритму случайного блуждания,
т.е. передвижение по осям Х и Y с шагом в один пиксель выбирается случайным образом.
Умершие своей смертью травоядные считаются съеденными хищниками.

При недоедании обеими популяциями, особи умирают в процессе увеличения возраста,
т.е. чем больше возраст животного, тем больше вероятность погибнуть от голода. Из-за
больших промежуточных расчетов учет по недоеданию выбрается так, что хищники
учитываются один раз в год, а травоядные - двенадцать раз в год.

Программу построить на обработке массивов, имеющих следующие параметры:
- x - расположение по координате Х экрана,
- y - расположение по координате Y экрана,
- age - возраст точки,
- col - цвет вывода на экран.

Программа должна обеспечивать следующие операции:
- задание параметров популяции
травоядных
- задание параметров популяции хищников,
- задание параметров окружающей среды,
- просмотр взаимодействия животных в графическом режиме,
- индикация результатов по выходу из режима просмотра взаимодействия животных,
- выход из программы.

***
# 102    Дорога для N городов

Имеется N городов. Для каждой пары городов (I,J) можно построить дорогу,
соединяющую эти два города и не заходящие в другие города. Стоимость такой дороги
A(I,J). Вне городов дороги не пересекаются. Написать алгоритм для нахождения самой
дешевой системы дорог, позволяющей попасть из любого города в любой другой.
Результаты задавать таблицей B[1:N,1:N], где B[I,J]=1 тогда и только тогда, когда дорогу,
соединяющую города I и J, следует строить.

***
# 103 Дорога для N городов

Вводится N - количество домов и К - количество дорог. Дома пронумерованы от 1 до N.
Каждая дорога определяется тройкой чисел - двумя номерами домов – концов дороги и
длиной дороги. В каждом доме живет по одному человеку. Найти точку - место встречи
всех людей, от которой суммарное расстояние до всех домов будет минимальным. Если
точка лежит на дороге, то указать номера домов - концов этой дороги и расстояние от
первого из этих домов. Если точка совпадает с домом, то указать номер этого дома.
Примечание: длины дорог - положительные целые числа.

***
# [Выполнено] 110    Монахи. 
Для предотвращения утечки информации в монастыре Святого Павла в
Калифорнии соблюдаются следующие правила:

1. каждый монах известен миру только по своему личному номеру;
2. у каждого монаха в течение жизни не может быть более трех учеников;
3. у каждого монаха есть только один учитель.

Составить программу, которая сможет решить следующие задачи:

1. по номеру монаха узнать, был ли такой монах и если был, то кто были его учитель,
учитель его учителя и т.д. до самого Святого Павла;
2. по двум монашеским номерам найти их общего ближайшего учителя.

Исходные данные о монахах представляют собой строки, в каждой из которых указан
номер монаха и после него три номера его учеников. Если у монаха было менее трех
учеников, то на соответствующих местах будут стоять нули.

Числовые данные для решения конкретной задачи – это строки, в каждой из которых
стоит код строки и один или два монашеских номера. Если код строки равен единице, то
за единицей будет стоять только один номер. Если код строки равен двум, то за двойкой
будет стоять два номера.

Указания:

1. монашеский номер Святого Павла равен единице;
2. номера всех остальных монахов – целые числа от 2 до 600;
3. номера монахов не обязательно последовательны, но номер ученика всегда больше,
чем номер его учителя.

Подсказки:

1. поиск учителей по номеру монаха рекомендуется делать с помощью рекурсии;
2. для ввода исходных данных о монахах следует использовать двумерный массив
600х3, так чтобы, например, A[45,2] означало: 2-й ученик 45-ого монаха;
3. для решения заданного варианта следует воспользоваться одномерным массивом
из 600 элементов, так чтобы, например, A[45] означало: учитель 45-ого монаха.

## Пример

Исходные данные о монахах:

```
32 41 42 43
25 31 32 0
24 33 34 0
13 24 25 0
11 21 22 23
1 11 12 13
```

Вариант задания:

```
1 31
1 51
2 34 41
2 31 51
```

Результаты работы программы:

```
31 – монах, его учителя 25, 13
51 – не монах
34 и 41 – оба монахи, и их общий учитель 13
51 – не монах
```

***
# [Выполнено] 111    Ханойская башня

Утверждается, что эту задачу сформулировали и решают до сих пор монахи каких-то
монастырей Тибета. Задача состоит в том, чтобы пирамидку из колец (на манер детской
игрушки), нанизанную на один из 3-х стержней, перенести на другой такой же стержень,
придерживаясь строгих правил:

- пирамидка состоит из n колец разного размера, уложенных по
убыванию диаметра колец одно на другое;
- перекладывать за одну операцию можно только одно кольцо с
любого штыря на любой, но только при условии, что класть можно
только меньшее кольцо сверху на большее, но никак не наоборот;
- нужно, в итоге, всю исходную пирамидку, лежащую на штыре No 1,
переместить на штырь No 3, используя штырь No 2 как
промежуточный.

Например, для 2-х колец результат получается такой вот последовательностью
перекладываний: 1 => 2, 1 => 3, 2 => 3.

По преданию эту задачу по перекладыванию n=64 колечек решают тибетские монахи, и
когда они её, наконец, решат, тогда и наступит конец света - Армагеддон в нашей
западной нотации.

Решение здесь (если его таковым можно назвать) состоит в том, чтобы при необходимости
переноса пирамиды из n колец с штыря с номером from на штырь с номером to
последовательно сделать следующее:
- перенести (каким-то образом) меньшую пирамиду из n-1 колец временно на штырь
с номером temp, чтобы не мешала;
- перенести оставшееся единственное нижнее (наибольшее) кольцо на
результирующий штырь с номером to, после чего, точно так же как в первом
пункте, водрузить пирамиду (n-1 колец) с номера temp поверх этого наибольшего
кольца на штырь с номером to.

Здесь важно то, что мы не знаем, каким образом выполнить алгоритм, и не умеем
выполнить 1-й и 3-й пункты нашей программы, но надеемся, что алгоритм будет
рекурсивно раскручиваться по аналогии, то есть по тому же алгоритму, но для меньшего
числа n-1 (основополагающий принцип рекурсии), пока n не станет равным 1, а там уже
совсем просто.

И вот как разворачивается решение для различных n:
```
n=2
1 => 2 | 1 => 3 | 2 => 3 |
общее число перемещений 3
n=3
1 => 3 | 1 => 2 | 3 => 2 | 1 => 3 | 2 => 1 | 2 => 3 | 1 => 3 |
общее число перемещений 7
n=4
1 => 2 | 1 => 3 | 2 => 3 | 1 => 2 | 3 => 1 |
3 => 2 | 1 => 2 | 1 => 3 | 2 => 3 | 2 => 1 |
3 => 1 | 2 => 3 | 1 => 2 | 1 => 3 | 2 => 3 |
общее число перемещений 15
n=5
1 => 3 | 1 => 2 | 3 => 2 | 1 => 3 | 2 => 1 |
2 => 3 | 1 => 3 | 1 => 2 | 3 => 2 | 3 => 1 |
2 => 1 | 3 => 2 | 1 => 3 | 1 => 2 | 3 => 2 |
1 => 3 | 2 => 1 | 2 => 3 | 1 => 3 | 2 => 1 |
3 => 2 | 3 => 1 | 2 => 1 | 2 => 3 | 1 => 3 |
1 => 2 | 3 => 2 | 1 => 3 | 2 => 1 | 2 => 3 | 1 => 3 |
общее число перемещений 31
```

Только не спровоцируйте конец света!

Число перестановок:

для n=10 потребуется 1023 перестановки;
для любого n число перестановок равно (2^n)–1, что представляет собой очень высокую
степень роста вычислительной сложности задачи — экспоненциальную.

Примечание: решить эту задачу не рекурсивными методами - очень непростое занятие!
